
============
Using Module
============

Now that we're familiar with the basics, we introduce Theano's more
advanced interface, Module. This interface allows you to define Theano
"objects" which can have many state variables and many methods sharing
these states. The Module system simplifies the way to define complex
systems such as a neural network.


Remake of the "state" example
=============================

Let's use Module to re-implement :ref:`the example using state
<functionstateexample>`.

>>> m = Module()
>>> m.state = T.dscalar()
>>> m.inc = T.dscalar('inc')
>>> m.new_state = m.state + m.inc
>>> m.add = Method(m.inc, m.new_state, {m.state: m.new_state})
>>> m.sub = Method(m.inc, None, {m.state: m.state - m.inc})
>>> acc = m.make(state = 0)
>>> acc.state, acc.inc
array(0.0), None
>>> acc.add(2)
array(2.0)
>>> acc.state, acc.inc
array(2.0), None
>>> acc.state = 39.99
>>> acc.add(0.01)
array(40.0)
>>> acc.state
array(40.0)
>>> acc.sub(20)
>>> acc.state
array(20.0)

This deserves to be broken up a bit...


>>> m = Module()

Here we instantiate an empty Module.


>>> m.state = T.dscalar()

Then we declare a Variable for use with our Module. That Variable will
be a :ref:`member` of the Module, which means that it will be
accessible as a field of the object we will create later (for reading
and writing). It will also be accessible from any :ref:`method`
defined in our Module.

.. note::

   There is no need to name the Variable explicitly here. ``m.state`` will
   be given the name 'state' automatically.


>>> m.inc = T.dscalar('inc')

The ``inc`` variable doesn't need to be declared as a member of ``m`` because
we only use it as a Method input.  

.. note::
 
  Since we made it a member of ``m``, the ``acc`` object will have an
  attribute called ``inc``.  This attribute will keep its default value of
  None throughout the example.


>>> m.new_state = m.state + m.inc

This line creates a Variable corresponding to some symbolic computation.  It
doesn't matter to Theano whether we put it inside ``m`` or not.  Feel free to
put such results of symbolic computation wherever is most convenient.


>>> m.add = Method(m.inc, m.new_state, {m.state: m.new_state})

Here we declare a Method. The three arguments are as follow:

* **inputs**: a list of input Variables
* **outputs**: a list of output Variables
* **updates**: a dictionary mapping member Variables to Variables.  When we
  call the function that this Method compiles to, it will replace (update) the
  values associated with the member Variables.

>>> acc = m.make(state = 0)

This line is what does the magic (well, compilation).
The ``m`` object contains symbolic things such as Variables and Methods. 
Calling ``make`` on ``m`` creates an object that can do real
computation and whose attributes contain values such as numbers and numpy
ndarrays.

The keyword arguments given to make are optional and are used to
assign initial values to each Member. If a Member is omitted, the
initial value is None.


>>> acc.state, acc.inc
array(0.0), None

Since state was declared as a Member, we can access it using
'.state'.

.. note::
  
  Members can also be accessed using a dictionary-like notation.  The syntax
  ``acc.value[m.state]`` is equivalent to ``acc[m.state]``, and in this case,
  ``acc.state``.  The dictionary-like syntax works for member Variables that
  appear inside sub-modules, lists, dictionaries, and for whatever reason have
  no name.

>>> acc.add(2)
array(2.0)
>>> acc.state
array(2.0)

When we call the ``acc.add`` method, all the updates given to the
corresponding Method's ``updates`` field are performed. We only had
one update which mapped ``state`` to ``new_state`` and you can see
that it works as intended, adding the argument to the internal state.


>>> acc.state = 39.99

The state can also be set.  When we manually set the value of a member
attribute like this, then subsequent calls to the methods of our module will
use the new value.

>>> acc.call(0.01)
array(40.0)
>>> acc.state
array(40.0)
>>> acc.sub(20)
>>> acc.state
array(20.0)

Here, note that ``acc.add`` and ``acc.sub`` share access to the same ``state``
value but update it in different ways.



Using Inheritance
=================

A friendlier way to use Module is to implement your functionality as a
subclass of Module:


.. code-block:: python

   class Accumulator(Module):

       def __init__(self):
           super(Accumulator, self).__init__() # don't forget this
           self.inc = T.dscalar()
           self.state = T.dscalar()
           self.new_state = self.inc + self.state
           self.add = Method(inputs = self.inc,
                             outputs = self.new_state,
                             updates = {self.state: self.new_state})
           self.sub = Method(inputs = self.inc,
                             outputs = None,
                             updates = {self.state: self.state - self.inc})

   m = Accumulator()
   acc = m.make(state = 0)


This is just like the previous example except slightly fancier.

.. warning::

   Do not forget to call the constructor of the parent class! (the
   call to ``super().__init__`` in the previous code block) If you
   forget it, you'll get strange behavior :(


Extending your Module with Python methods
=========================================

Let's say we want to add a method to our accumulator to print out the
state and we want to call it ``print_state``. All we need to do is to
give a method called ``_instance_print_state`` to our Module.


.. code-block:: python

   class Accumulator(Module):

       def __init__(self):
           super(Accumulator, self).__init__() # don't forget this
           self.inc = T.dscalar()
           self.state = T.dscalar()
           self.new_state = self.inc + self.state
           self.add = Method(inputs = self.inc,
                             outputs = self.new_state,
                             updates = {self.state: self.new_state})
           self.sub = Method(inputs = self.inc,
                             outputs = None,
                             updates = {self.state: self.state - self.inc})

       def _instance_print_state(self, acc):
           print '%s is: %s' % (self.state, acc.state)

   m = Accumulator()
   acc = m.make(state = 0)

   acc.print_state() # --> prints "state is: 0.0"


Any method called like ``_instance_XXX`` will variable in the object
obtained through a call to ``make`` to gain an ``XXX`` method. Note
that when we define ``_instance_print_state`` there are two "self"
arguments: ``self`` which is *symbolic* and ``obj`` which contains
*data*. Therefore, ``self.state`` is the symbolic state variable and
prints out as "state", whereas ``obj.state`` is the state's actual
value in the accumulator and prints out as "0.0".


Adding custom initialization
============================

As was said in the previous section, you can add functionality with
``_instance_XXX`` methods. One of these methods is actually special:
``_instance_initialize`` will be called with whatever arguments you
give to ``make``. There is a default behavior which we have used,
where we give the states' initial values with keyword arguments
(``acc.make(state = 0)``). If you want more personalized behavior, you
can override the default with your own method, which has to be called
``_instance_initialize``.

Here is an example where we take width and height arguments to
initialize a state with a matrix of zeros:


.. code-block:: python

   import numpy

   class MatrixAccumulator(Module):

       def __init__(self):
           super(MatrixAccumulator, self).__init__() # don't forget this
           self.inc = T.dscalar()
           self.state = T.dmatrix()
           self.new_state = self.inc + self.state
           self.add = Method(inputs = self.inc,
                             outputs = self.new_state,
                             updates = {self.state: self.new_state})
           self.sub = Method(inputs = self.inc,
                             outputs = None,
                             updates = {self.state: self.state - self.inc})

       def _instance_print_state(self, acc):
           print '%s is: %s' % (self.state, acc.state)

       def _instance_initialize(self, acc, nrows, ncols):
           acc.state = numpy.zeros((nrows, ncols))

   m = Accumulator()
   acc = m.make(2, 5) # this calls m._instance_initialize(acc, 2, 5)

   acc.print_state()

   # OUTPUT:
   # state is: [[ 0.  0.  0.  0.  0.]
   #  [ 0.  0.  0.  0.  0.]]


Nesting Modules
===============

WRITEME




