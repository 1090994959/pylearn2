
============
Using Module
============

Now that we're familiar with the basics, we introduce Theano's more
advanced interface, Module. This interface allows you to define Theano
"objects" which can have many state variables and many methods sharing
these states. The Module system simplifies the way to define complex
systems such as a neural network.


Remake of the "state" example
=============================

Let's use Module to re-implement :ref:`the example using state
<functionstateexample>`.

>>> m = Module()
>>> m.state = T.dscalar()
>>> m.inc = T.dscalar('inc')
>>> m.new_state = m.state + m.inc
>>> m.add = Method(m.inc, m.new_state, {m.state: m.new_state})
>>> m.sub = Method(m.inc, None, {m.state: m.state - m.inc})
>>> acc = m.make(state = 0)
>>> acc.state, acc.inc
array(0.0), None
>>> acc.add(2)
array(2.0)
>>> acc.state, acc.inc
array(2.0), None
>>> acc.state = 39.99
>>> acc.add(0.01)
array(40.0)
>>> acc.state
array(40.0)
>>> acc.sub(20)
>>> acc.state
array(20.0)

This deserves to be broken up a bit...


>>> m = Module()

Here we instantiate an empty Module.


>>> m.state = T.dscalar()
>>> m.inc = T.dscalar('inc')

Then we declares for use with our Module.
Since we assign these input Variables as attributes of the Module, 
they will be *member Variables* of the Module. 
Member Variables are special in a few ways, which we will see shortly.

.. note::

   There is no need to name the Variable explicitly here. ``m.state`` will
   be given the name 'state' automatically.


.. note::
 
  Since we made it a member of ``m``, the ``acc`` object will have an
  attribute called ``inc``.  This attribute will keep its default value of
  None throughout the example.


>>> m.new_state = m.state + m.inc

This line creates a Variable corresponding to some symbolic computation.
Although this line also assigns a Variable to a Module attribute, it does not
become a member Variable like state and inc because it represents an expression
result.


>>> m.add = Method(m.inc, m.new_state, {m.state: m.new_state})

Here we declare a Method. The three arguments are as follow:

* **inputs**: a list of input Variables
* **outputs**: a list of output Variables
* **updates**: a dictionary mapping member Variables to Variables.  When we
  call the function that this Method compiles to, it will replace (update) the
  values associated with the member Variables.

>>> acc = m.make(state = 0)

This line is what does the magic (well, compilation).
The ``m`` object contains symbolic things such as Variables and Methods. 
Calling ``make`` on ``m`` creates an object that can do real
computation and whose attributes contain values such as numbers and numpy
ndarrays.

At this point something special happens for our member Variables too.
In the 'acc' object, make allocates room to store numbers for m's member
Variables.  By using the string 'state' as a keyword argument, we tell Theano to
store the number 0 for the member Variable called 'state'.  By not mentioning
the 'inc' variable, we associate None to the 'inc' Variable.


>>> acc.state, acc.inc
array(0.0), None

Since 'state' was declared as a member Variable of 'm', we can access it's value
in the 'acc' object by the same attribute.  Ditto for 'inc'.

.. note::
  
  Members can also be accessed using a dictionary-like notation.  The syntax
  ``acc.value[m.state]`` is equivalent to ``acc[m.state]``, and in this case,
  ``acc.state``.  The dictionary-like syntax works for member Variables that
  appear inside sub-modules, lists, dictionaries, and for whatever reason have
  no name.

>>> acc.add(2)
array(2.0)
>>> acc.state, acc.inc
array(2.0), None

When we call the ``acc.add`` method, all the updates given to the
corresponding Method's ``updates`` field are performed. We only had
one update which mapped ``state`` to ``new_state`` and you can see
that it works as intended, adding the argument to the internal state.


>>> acc.state = 39.99

The state can also be set.  When we manually set the value of a member
attribute like this, then subsequent calls to the methods of our module will
use the new value.

>>> acc.call(0.01)
array(40.0)
>>> acc.state
array(40.0)
>>> acc.sub(20)
>>> acc.state
array(20.0)

Here, note that ``acc.add`` and ``acc.sub`` share access to the same ``state``
value but update it in different ways.



Using Inheritance
=================

A friendlier way to use Module is to implement your functionality as a
subclass of Module:


.. code-block:: python

   class Accumulator(Module):

       def __init__(self):
           super(Accumulator, self).__init__() # don't forget this
           self.inc = T.dscalar()
           self.state = T.dscalar()
           self.new_state = self.inc + self.state
           self.add = Method(inputs = self.inc,
                             outputs = self.new_state,
                             updates = {self.state: self.new_state})
           self.sub = Method(inputs = self.inc,
                             outputs = None,
                             updates = {self.state: self.state - self.inc})

   m = Accumulator()
   acc = m.make(state = 0)


This is just like the previous example except slightly fancier.

.. warning::

   Do not forget to call the constructor of the parent class! (the
   call to ``super().__init__`` in the previous code block) If you
   forget it, you'll get strange behavior :(


Extending your Module with Python methods
=========================================

Let's say we want to add a method to our accumulator to print out the
state and we want to call it ``print_state``. All we need to do is to
give a method called ``_instance_print_state`` to our Module.


.. code-block:: python

   class Accumulator(Module):

       def __init__(self):
           super(Accumulator, self).__init__() # don't forget this
           self.inc = T.dscalar()
           self.state = T.dscalar()
           self.new_state = self.inc + self.state
           self.add = Method(inputs = self.inc,
                             outputs = self.new_state,
                             updates = {self.state: self.new_state})
           self.sub = Method(inputs = self.inc,
                             outputs = None,
                             updates = {self.state: self.state - self.inc})

       def _instance_print_state(self, acc):
           print '%s is: %s' % (self.state, acc.state)

   m = Accumulator()
   acc = m.make(state = 0)

   acc.print_state() # --> prints "state is: 0.0"


Any method called like ``_instance_XXX`` will variable in the object
obtained through a call to ``make`` to gain an ``XXX`` method. Note
that when we define ``_instance_print_state`` there are two "self"
arguments: ``self`` which is *symbolic* and ``obj`` which contains
*data*. Therefore, ``self.state`` is the symbolic state variable and
prints out as "state", whereas ``obj.state`` is the state's actual
value in the accumulator and prints out as "0.0".


Adding custom initialization
============================

As was said in the previous section, you can add functionality with
``_instance_XXX`` methods. One of these methods is actually special:
``_instance_initialize`` will be called with whatever arguments you
give to ``make``. There is a default behavior which we have used,
where we give the states' initial values with keyword arguments
(``acc.make(state = 0)``). If you want more personalized behavior, you
can override the default with your own method, which has to be called
``_instance_initialize``.

Here is an example where we take width and height arguments to
initialize a state with a matrix of zeros:


.. code-block:: python

   import numpy

   class MatrixAccumulator(Module):

       def __init__(self):
           super(MatrixAccumulator, self).__init__() # don't forget this
           self.inc = T.dscalar()
           self.state = T.dmatrix()
           self.new_state = self.inc + self.state
           self.add = Method(inputs = self.inc,
                             outputs = self.new_state,
                             updates = {self.state: self.new_state})
           self.sub = Method(inputs = self.inc,
                             outputs = None,
                             updates = {self.state: self.state - self.inc})

       def _instance_print_state(self, acc):
           print '%s is: %s' % (self.state, acc.state)

       def _instance_initialize(self, acc, nrows, ncols):
           acc.state = numpy.zeros((nrows, ncols))

   m = Accumulator()
   acc = m.make(2, 5) # this calls m._instance_initialize(acc, 2, 5)

   acc.print_state()

   # OUTPUT:
   # state is: [[ 0.  0.  0.  0.  0.]
   #  [ 0.  0.  0.  0.  0.]]


Nesting Modules
===============

WRITEME




