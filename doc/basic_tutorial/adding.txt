.. _adding:

========================================
Baby steps - Adding two numbers together
========================================


Adding two scalars
==================

So, to get us started and get a feel of what we're working with, let's
make a simple function: add two numbers together. Here is how you do
it:

>>> x = T.dscalar('x')
>>> y = T.dscalar('y')
>>> z = x + y
>>> f = function([x, y], z)

And now that we've created our function we can use it:

>>> f(2, 3)
array(5.0)
>>> f(16.3, 12.1)
array(28.4)


Let's break this down into several steps. The first step is to define
two symbols, or Variables, representing the quantities that you want
to add. Note that from now on, we will use the term :term:`Variable`
to mean "symbol" (in other words, ``x``, ``y``, ``z`` are all Variable
objects). The output of the function ``f`` is a ``numpy.ndarray``
with zero dimensions.

If you are following along and typing into an interpreter, you may have
noticed that there was a slight delay in executing the ``function``
instruction. Behind the scenes, ``f`` was being compiled into C code.

    .. TODO: help

-------------------------------------------

**Step 1**

>>> x = T.dscalar('x')
>>> y = T.dscalar('y')

In Theano, all symbols must be typed. In particular, ``T.dscalar``
is the type we assign to "0-dimensional arrays (`scalar`) of doubles
(`d`)". It is a Theano :term:`Type`.

``dscalar`` is not a class. Therefore, neither ``x`` nor ``y``
are actually instances of ``dscalar``. They are instances of
:api:`TensorVariable <theano.tensor.basic.TensorVariable>`. ``x`` and ``y``
are, however, assigned the theano Type ``dscalar`` in their ``type``
field, as you can see here:

>>> type(x)
<class 'theano.tensor.basic.TensorVariable'>
>>> x.type
TensorType(float64, scalar)
>>> T.dscalar
TensorType(float64, scalar)
>>> x.type == T.dscalar
True

You can learn more about the structures in Theano in
the :ref:`advtutorial` and in :ref:`graphstructures`.

By calling ``T.dscalar`` with a string argument, you create a
:term:`Variable` representing a floating-point scalar quantity with the
given name. If you provide no argument, the symbol will be unnamed. Names
are not required, but they can help debugging.

-------------------------------------------

**Step 2**

The second step is to combine ``x`` and ``y`` into their sum ``z``:

>>> z = x + y

``z`` is yet another :term:`Variable` which represents the addition of
``x`` and ``y``. You can use the :api:`pp <theano.printing.pp>`
function to pretty-print out the computation associated to ``z``.

>>> print pp(z)
(x + y)

-------------------------------------------

**Step 3**

The last step is to create a function taking ``x`` and ``y`` as inputs
and giving ``z`` as output:

>>> f = function([x, y], z)

The first argument to ``function`` is a list of :term:`Variables <Variable>`
that will be provided as inputs to the function. The second argument
is a single Variable *or* a list of Variables. For either case, the second
argument is what we want to see as output when we apply the function.

``f`` may then be used like a normal Python function.


Adding two matrices
===================

You might already have guessed how to do this. Indeed, the only change
from the previous example is that you need to instantiate ``x`` and
``y`` using the matrix Types:

>>> x = T.dmatrix('x')
>>> y = T.dmatrix('y')
>>> z = x + y
>>> f = function([x, y], z)

``dmatrix`` is the Type for matrices of doubles. And then we can use
our new function on 2D arrays:

>>> f([[1, 2], [3, 4]], [[10, 20], [30, 40]])
array([[ 11.,  22.],
       [ 33.,  44.]])

The variable is a numpy array. We can also use numpy arrays directly as
inputs:

>>> import numpy
>>> f(numpy.array([[1, 2], [3, 4]]), numpy.array([[10, 20], [30, 40]]))
array([[ 11.,  22.],
       [ 33.,  44.]])

It is possible to add scalars to matrices, vectors to matrices,
scalars to vectors, etc. The behavior of these operations is defined
by :term:`broadcasting`.

The following types are available:

* **byte**: bscalar, bvector, bmatrix
* **32-bit integers**: iscalar, ivector, imatrix
* **64-bit integers**: lscalar, lvector, lmatrix
* **float**: fscalar, fvector, fmatrix
* **double**: dscalar, dvector, dmatrix

The previous list is not exhaustive. A guide to all types compatible
with numpy arrays may be found :ref:`here <predefinedtypes>`.

.. note::

   You, the user---not the system architecture---have to choose whether your
   program will use 32- or 64-bit integers (``i`` prefix vs. the ``l`` prefix)
   and floats (``f`` prefix vs. the ``d`` prefix).
