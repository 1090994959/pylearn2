
.. _basictutexamples:

=============
More examples
=============


Logistic function
=================

Here's another straightforward example, though a bit more elaborate
than adding two numbers together. Let's say that you want to compute
the logistic curve, which is given by:

.. math::

   s(x) = \frac{1}{1 + e^{-x}}

.. figure:: logistic.png

    A plot of the logistic function, with x on the x-axis and s(x) on the
    y-axis.

You want to compute the function :term:`elementwise` on matrices of
doubles, which means that you want to apply this function to each
individual element of the matrix.

Well, what you do is this:

>>> x = T.dmatrix('x')
>>> s = 1 / (1 + T.exp(-x))
>>> logistic = function([x], s)
>>> logistic([[0, 1], [-1, -2]])
array([[ 0.5       ,  0.73105858],
       [ 0.26894142,  0.11920292]])

The reason logistic is performed elementwise is because all of its
operations---division, addition, exponentiation, and division---are
themselves elementwise operations.

It is also the case that:

.. math::

    s(x) = \frac{1}{1 + e^{-x}} = \frac{1 + \tanh(x/2)}{2}

We can verify that this alternate form produces the same values:

>>> s2 = (1 + T.tanh(x / 2)) / 2
>>> logistic2 = function([x], s2)
>>> logistic2([[0, 1], [-1, -2]])
array([[ 0.5       ,  0.73105858],
       [ 0.26894142,  0.11920292]])


Computing more than one thing at the same time
==============================================

Theano supports functions with multiple outputs. For example, we can
compute the :term:`elementwise` difference, absolute difference, and
squared difference between two matrices ``x`` and ``y`` at the same time:

>>> x, y = T.dmatrices('x', 'y')
>>> diff = x - y
>>> abs_diff = abs(diff)
>>> diff_squared = diff**2
>>> f = function([x, y], [diff, abs_diff, diff_squared])

When we use the function, it will return the two results (the printing
was reformatted for readability):

>>> f([[1, 1], [1, 1]], [[0, 1], [2, 3]])
[array([[ 1.,  0.],
        [-1., -2.]]),
 array([[ 1.,  0.],
        [ 1.,  2.]]),
 array([[ 1.,  0.],
        [ 1.,  4.]])]

Also note the call to ``dmatrices``. This is a shortcut, use it wisely
;)


Computing gradients
===================

Now let's use Theano for a slightly more sophisticated task: create a
function which computes the derivative of some expression ``y`` with
respect to its parameter ``x``. For instance, we can compute the
gradient of :math:`x^2` with respect to :math:`x`. Note that:
:math:`d(x^2)/dx = 2 \cdot x`.

Here is code to compute this gradient:

>>> x = T.dscalar('x')
>>> y = x**2
>>> gy = T.grad(y, x)
>>> pp(gy)
'fill(x ** 2, 1.0) * 2 * x ** (2 - 1)'
>>> f = function([x], gy)
>>> f(4)
array(8.0)
>>> f(94.2)
array(188.40000000000001)

In the example above, we can see from ``pp(gw)`` that we are computing
the correct symbolic gradient.
``fill(x ** 2, 1.0)`` means to make a matrix of the same shape as ``x **
2`` and fill it with 1.0.

.. note::
    The optimizer will simplify the symbolic gradient expression.

We can also compute the gradient of complex expressions such as the
logistic function defined above. It turns out that the derivative of the
logistic is: :math:`ds(x)/dx = s(x) \cdot (1 - s(x))`.

.. figure:: dlogistic.png

    A plot of the gradient of the logistic function, with x on the x-axis
    and :math:`ds(x)/dx` on the y-axis.

>>> x = T.dmatrix('x')
>>> s = 1 / (1 + T.exp(-x))
>>> gs = T.grad(s, x)
>>> dlogistic = function([x], gs)
>>> dlogistic([[0, 1], [-1, -2]])
array([[ 0.25      ,  0.19661193],
       [ 0.19661193,  0.10499359]])


The resulting function computes the gradient of its first argument
with respect to the second. In this way, Theano can be used for
`automatic differentiation`_.

.. note::

   The result of ``T.grad`` has the same dimensions as the
   second argument. This is exactly like the first derivative if the
   first argument is a scalar or a tensor of size 1 but not if it is
   larger. For more information on the semantics when the first
   argument has a larger size and details about the implementation,
   see the :ref:`gradient` section.


Setting a default value for an argument
=======================================

Let's say you want to define a function that adds two numbers, except
that if you only provide one number, the other input is assumed to be
one. You can do it like this:

>>> x, y = T.dscalars('x', 'y')
>>> z = x + y
>>> f = function([x, (y, 1)], z)
>>> f(33)
array(34.0)
>>> f(33, 2)
array(35.0)

The syntax is that if one of the elements in the list of inputs is a
pair, the input is the first element of the pair and the second
element is its default value. Here ``y``'s default value is set to 1.

Inputs with default values should (must?) follow inputs without default
values.  There can be multiple inputs with default values. Defaults can
be set positionally or by name, as in standard Python:

>>> x, y, w = T.dscalars('x', 'y', 'w')
>>> z = (x + y) * w
>>> f = function([x, (y, 1), (w, 2)], z)
>>> f(33)
array(68.0)
>>> f(33, 2)
array(70.0)
>>> f(33, 0, 1)
array(33.0)
>>> f(33, w=1)
array(34.0)
>>> f(33, w=1, y=0)
array(33.0)
>>> f(33, w=1, 2)
<type 'exceptions.SyntaxError'>: non-keyword arg after keyword arg (<ipython console>, line 1)


.. _functionstateexample:

Making a function with state
============================

It is also possible to make a function with an internal state. For
example, let's say we want to make an accumulator: at the beginning,
the state is initialized to zero. Then, on each function call, the state
is incremented by the function's argument. We'll also make it so that
the increment has a default value of 1.

First let's define the accumulator function:

>>> inc = T.scalar('inc')
>>> state = T.scalar('state')
>>> new_state = state + inc
>>> accumulator = function([(inc, 1), ((state, new_state), 0)], new_state)

The first argument is a pair. As we saw in the previous section, this
means that ``inc`` is an input with a default value of 1. The second
argument has syntax that creates an internal state.  The syntax is
``((state_result, new_state_result), initial_value)``.
The internal storage associated with ``state_result`` is initialized to
``initial_value``.  Every time ``accumulator`` is called, the value
of the internal ``state`` will be replaced by the value computed as
``new_state``. In this case, the state will be replaced by the result
of incrementing it by ``inc``.

We recommend (insist?) that internal state arguments occur after any
plain arguments and arguments with default values.

There is no limit to how many states you can have. You can add an
arbitrary number of elements to the input list which correspond to the
syntax described in the previous paragraph. You can name the states
however you like as long as the name does not conflict with the names
of other inputs.

Anyway, let's try it out! The state can be accessed using the square
brackets notation ``[]``. You may access the state either by using
the :ref:`result` representing it or the name of that
:ref:`result`. In our example we can access the state either with the
``state`` object or the string 'state'.

>>> accumulator[state]
array(0.0)
>>> accumulator['state']
array(0.0)

Here we use the accumulator and check that the state is correct each
time:

>>> accumulator()
array(1.0)
>>> accumulator['state']
array(1.0)
>>> accumulator(300)
array(301.0)
>>> accumulator['state']
array(301.0)

It is possible to reset the state. This is done
by assigning to the state using the square brackets
notation:

>>> accumulator['state'] = 5
>>> accumulator(0.9)
array(5.9000000000000004)
>>> accumulator['state']
array(5.9000000000000004)


**Next:** `Using Module`_

.. _Using Module: module.html
.. _automatic differentiation: http://en.wikipedia.org/wiki/Automatic_differentiation

