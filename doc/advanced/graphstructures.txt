
.. _graphstructures:

================
Graph Structures
================


.. index::
   single: Apply
   single: graph construct; Apply

.. _apply:

-----
Apply
-----

An *Apply node* is a type of internal node used to represent a
:term:`computation graph <graph>` in Theano. Unlike
:ref:`Result nodes <result>`, Apply nodes are usually not
manipulated directly by the end user. They may be accessed via
a Result's ``owner`` field.

An Apply node is typically an instance of the :api:`Apply
<theano.gof.graph.Apply>` class. It represents the application
of an :ref:`op` on one or more inputs, where each input is a
:ref:`result`. By convention, each Op is responsible for
knowing how to build an Apply node from a list of
inputs. Therefore, an Apply node may be obtained from an Op
and a list of inputs by calling ``Op.make_node(*inputs)``.

Comparing with the Python language, an :ref:`apply` node is
theano's version of a function call whereas an :ref:`op` is
theano's version of a function definition.

An Apply instance has three important fields:

**inputs**
  A list of :ref:`Results <result>` that represent the arguments of
  the function.

**outputs**
  A list of :ref:`Results <result>` that represent the return values
  of the function.

**op**
  An :ref:`op` that determines the function/transformation being
  applied here.


.. index::
   single: Constant
   single: graph construct; Constant

.. _constant:

--------
Constant
--------

A constant is a :ref:`Result` with one extra field, *data* (only
settable once). When used in a computation graph as the input of an
:ref:`Op` :ref:`application <Apply>`, it is assumed that said input
will *always* take the value contained in the constant's data
field. Furthermore, it is assumed that the :ref:`Op` will not under
any circumstances modify the input. This means that a constant is
eligible to participate in numerous optimizations: constant inlining
in C code, constant folding, etc.

A constant does not need to be specified in a :ref:`function`'s list
of inputs.



.. index::
   single: Result
   single: graph construct; Result

.. _result:

------
Result
------

A :ref:`result` is the main data structure you work with when using
Theano. The symbolic inputs that you operate on are Results and what
you get from applying various operations to these inputs are also
Results. For example, when I type

>>> x = theano.tensor.ivector()
>>> y = -x

``x`` and ``y`` are both Results, i.e. instances of the :api:`Result
<theano.gof.graph.Result>` class. The :ref:`type` of both ``x`` and
``y`` is ``theano.tensor.ivector``.

Despite what the name might suggest, a Result is not necessarily
produced by a computation. Indeed, in the example above, ``x`` is only
an input. However, it is still called a Result for historical reasons
(and because the data structure is identical).

Now, unlike ``x``, ``y`` is indeed produced by a computation (in this
case, negation of x). ``y`` is the Result corresponding to the output
of the computation, while ``x`` is the Result corresponding to its
input. The computation itself is represented by another type of node,
an :ref:`apply` node, and may be accessed through ``y.owner``.

More specifically, a Result is a basic structure in Theano that
represents a datum at a certain point in computation. It is typically
an instance of the class :api:`Result <theano.gof.graph.Result>` or
one of its subclasses.

A Result ``r`` contains four important fields:

**type**
  a :ref:`type` defining the kind of value this Result can hold in
  computation.

**owner**
  this is either None or an :ref:`apply` node of which the Result is
  an output.

**index**
  the integer such that ``owner.outputs[index] is r`` (ignored if
  ``owner`` is None)

**name**
  a string to use in pretty-printing and debugging.

Result has one special subclass: :ref:`constant <constant>`.



.. index::
   single: Op
   single: graph construct; Op

.. _op:

--
Op
--

WRITEME



.. index::
   single: Type
   single: graph construct; Type

.. _type:

----
Type
----

WRITEME

