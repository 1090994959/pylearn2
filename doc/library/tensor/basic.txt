
.. currentmodule:: tensor


.. _libdoc_tensor_type:


TensorType
==========

.. class:: TensorType

   .. method:: quux()



.. _libdoc_tensor_creation:


Creation
========

Autocasting
-----------

TODO: What does (or compatible) mean?  Talk about casting rules, refer .


.. function:: as_tensor_variable(x, ...)

    TODO: Link to 'autocasting'


.. function:: lvector(name=None)

TODO: make a table of all [scalar, vector, matrix, tensor3, tensor4] vs. [b,
w, i, l, f, d, c, z]


Shaping and Shuffling
=====================

.. function:: shape(x)

    :param x:  symbolic Tensor (or compatible)

    Returns the symbolic shape vector of `x`

.. function:: reshape(x)

.. function:: dimshuffle(x)


Reductions 
==========


.. function:: max(x)

    :param x:  symbolic Tensor (or compatible)

    Returns TODO

.. function:: min(x)

    :param x:  symbolic Tensor (or compatible)

    Returns TODO

.. function:: sum(x)

    :param x:  symbolic Tensor (or compatible)

    Returns TODO

Indexing
========

Basic indexing.

Advanced indexing.

.. _libdoc_tensor_elementwise:


Elementwise
===========

Casting
-------

Logic Functions
---------------

Mathematical
------------

.. _libdoc_tensor_broadcastable:

Broadcasting in Theano vs. Numpy
--------------------------------

Broadcasting is a mechanism which allows tensors with
different numbers of dimensions to be added or multiplied
together by (virtually) replicating the smaller tensor along
the dimensions that it is lacking.

In a nutshell, broadcasting is the mechanism by which a scalar
may be added to a matrix, a vector to a matrix or a scalar to
a vector.

.. figure:: bcast.png

Broadcasting a row matrix. T and F respectively stand for
True and False and indicate along which dimensions we allow
broadcasting.

If the second argument were a vector, its shape would be
``(2,)`` and its broadcastable pattern ``(F,)``. They would
be automatically expanded to the **left** to match the
dimensions of the matrix (adding ``1`` to the shape and ``T``
to the pattern), resulting in ``(1, 2)`` and ``(T, F)``.
It would then behave just like the example above.


Unlike numpy which does broadcasting dynamically, Theano needs
to know, for any operation which supports broadcasting, which
dimensions will need to be broadcasted. When applicable, this
information is given in the :ref:`type` of a *Variable*.

See also:

* :ref:`How broadcasting is used in Theano's tensor types <tensortypes>`

* `SciPy documentation about numpy's broadcasting <http://www.scipy.org/EricsBroadcastingDoc>`_

* `OnLamp article about numpy's broadcasting <http://www.onlamp.com/pub/a/python/2000/09/27/numerically.html>`_




Linear Algebra
==============



Fourier Transforms
==================

[James has some code for this, but hasn't gotten it into the source tree yet.]
=
