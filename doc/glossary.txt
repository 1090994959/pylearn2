.. _glossary:

Glossary of terminology
=======================

.. glossary::

    Apply
        WRITEME

    broadcasting
        Broadcasting is a mechanism which allows tensors with
        different numbers of dimensions to be added or multiplied
        together by (virtually) replicating the smaller tensor along
        the dimensions that it is lacking.

        In a nutshell, broadcasting is the mechanism by which a scalar
        may be added to a matrix, a vector to a matrix or a scalar to
        a vector.

        .. figure:: bcast.png

           Broadcasting a row matrix. T and F respectively stand for
           True and False and indicate along which dimensions we allow
           broadcasting.
        
        Unlike numpy which does broadcasting dynamically, Theano needs
        to know, for any operation which supports broadcasting, which
        dimensions will need to be broadcasted. When applicable, this
        information is given in the :term:`Type` of a :term:`Result`.
        
        See also:

        * `SciPy documentation about numpy's broadcasting <http://www.scipy.org/EricsBroadcastingDoc>`_
        * `OnLamp article about numpy's broadcasting <http://www.onlamp.com/pub/a/python/2000/09/27/numerically.html>`_

    constant
        WRITEME

    elementwise
        An elementwise operation ``f`` on two matrices ``M`` and ``N``
        is one such that:
        
        ``f(M, N)[i, j] = f(M[i, j], N[i, j])``

        In other words, each element of an input matrix is combined
        with the corresponding element of the other(s). There are no
        dependencies between elements whose ``[i, j]`` coordinates do
        not correspond, so an elementwise operation is like a scalar
        operation generalized along several dimensions.

        There exist unary, binary, ternary, etc. elementwise
        operations and they can work on scalars, vectors, matrices,
        etc. as long as all the inputs have the same dimensions or can
        be :term:`broadcasted <broadcasting>` to the same dimensions.

        Examples of elementwise operations in Theano: ``add, sub, mul,
        div, neg, inv, log, exp, sin, cos, tan`` and many
        others. These operations are all subclasses of :api:`Elemwise
        <theano.tensor.elemwise.Elemwise>`.

    graph
        WRITEME

    inplace
        WRITEME

    op
        WRITEME

    Result 
        A :ref:`result` is the main data structure you work with when
        using Theano. The symbolic inputs that you operate on are
        Results and what you get from applying various operations to
        these inputs are also Results. For example, when I type

        >>> x = theano.tensor.ivector()
        >>> y = -x

        ``x`` and ``y`` are both Results, i.e. instances of the
        :api:`Result <theano.gof.graph.Result>` class. The
        :term:`Type` of both ``x`` and ``y`` is
        ``theano.tensor.ivector``.

        For more information, see: :ref:`result`.

    type
        WRITEME

    view
        WRITEME







































..
    Apply
        TRANSFERRED
        
    Broadcasting
        TRANSFERRED
        
    Build
        see :term:`Compilation`
        
    Compilation
        use a mode to transform graph into a callable
        
        Compilation is the transformation of a graph into a callable object instance.
        Compilation is implemented by the :ref:`theano.function() <CompileFunction>` function.
        
        As far as compilation is concerned, ``theano.function()`` accepts three important arguments: a list of inputs, a list of outputs, and a :term:`mode`:
            #. use ``owner`` and ``input`` fields to identify the intermediate nodes connecting inputs to outputs
            #. copy that sub-graph into an internal :term:`Env` instance
            #. use the Env to transform the subgraph copy (introduce :term:`optimizations <Optimization>` and :term:`stabilizations <Stabilization>`)
            #. serialize the transformed subgraph by topological sort
            #. allocate a :term:`linker` to perform the calculations associated with each :term:`Op`.
        
        The :term:`mode` defines how optimizations and stabilizations will be introduced, and defines which linker will be used.

    Constant
        TRANSFERRED    

    DType
        the numeric type for :term:`Tensor` elements

        A :term:`Tensor` is for storing a number of objects that
        all have the same type.  In computations, the storage for
        :term:`TensorResult` instances is a ``numpy.ndarray``.
        Instances of ``numpy.ndarray`` have a ``dtype`` property
        to indicate which data type (i.e., byte, float, double, python
        object) can be stored in each element.  The ``dtype`` property
        of Tensors is a little different: it is a string which can be
        converted to a numpy ``dtype`` object.  Still the meaning
        is pretty much the same: elements of the ``numpy.ndarray``
        corresponding to a :term:`TensorResult` in a particular
        computation must have the corresponding data type.


    Env
        important class during compilation

        WRITEME

    Function
        callable object representing a compiled graph

        It is created through ``theano.function``.

        WRITEME

    Graph
        TRANSFERRED


    Graph Transformation
        compilation stage

        :term:`Env`, in particular `replace()
        <http://lgcm.iro.umontreal.ca/epydoc/theano.gof.env.Env-class.html#replace
        replace()>`_

        See also `Optimizer
        <http://lgcm.iro.umontreal.ca/epydoc/theano.gof.opt.Optimizer-class.html>`_,
        which is the base interface for writing transformers, such as
        :term:`optimizations <Optimization>` and :term:`stabilizations
        <Stabilization>`.

        WRITEME

    Linker
        object which executes serialized graphs after compilation

        WRITEME

    Mode
        mode of compilation (linker, transformer)

        WRITEME

    Module
        See :ref:`Module`.

    Op
        a type of operation. Instance is TOI

        :term:`Op` is an abstract class (`Op API
        <http://lgcm.iro.umontreal.ca/epydoc/theano.gof.op.Op-class.html>`_)
        that documents the interface for theano's data
        transformations.  It has many subclasses, such as `sparse Dot
        <http://lgcm.iro.umontreal.ca/epydoc/theano.sparse.Dot-class.html>`_.
        and `Shape
        <http://lgcm.iro.umontreal.ca/epydoc/theano.tensor.Shape-class.html>`_.


        Comparing with the Python language, :term:`Op` is theano's
        version of a function definition where an :term:`Apply` instance
        is theano's version of a function call (or expression instance).

        These subclasses are meant to be instantiated, and I'll call
        an instance a theano Op instance (TOI).  A TOI has several
        important responsabilities:

            * making :term:`Apply` instances, which mean "apply this TOI to some particular inputs" (via the ``make_node``),
            * performing the calculation of outputs from given inputs (via the ``perform``),
            * producing c code to perform calculation of outputs from inputs (via ``c_code, c_code_cleanup, c_support_code, c_headers, c_libraries, c_compile_args``)
            * [optionally] building gradient-calculating graphs (via ``grad``).

        See :ref:`intro_to_ops`.
        
    Optimization
        graph transformation for faster execution
        
        An optimization is a type of :term:`graph transformation`.
        
        WRITEME.
        
    Result
        a Type-related graph node (a variable)
        
        A Result
        (`Result API <http://lgcm.iro.umontreal.ca/epydoc/theano.gof.graph.Result-class.html>`_)
        is theano's variable.  It symbolically represents a value (which
        can be a number, vector, matrix, tensor, etc.).
        The inputs and outputs of every :term:`Op` are Result instances.
        The input and output arguments to create a :term:`function` are also Results.
        A Result is like a strongly-typed variable in some other languages; each Result contains a reference to a :term:`TTI` (Theano Type Instance) that defines the kind of value that can be associated to the Result by a :term:`function`.
        
        A Result is a container for four important fields:
            type
                a :term:`TTI` defining the kind of value this Result can have,
            owner
                either None (for graph roots) or the :term:`Apply` instance (i.e. result of applying an :term:`Op`) of which ``self`` is an output,
            index
                the integer such that ``owner.outputs[index] is this_result`` (ignored if ``owner`` is None)
            name
                a string to use in pretty-printing and debugging.
        
        There are two subclasses related to Result:
            :term:`Value`
                a Result with a data field.
            :term:`Constant`
                like ``Value``, but the data it contains cannot be modified.

        See :ref:`intro_to_types`.
        
        Code Example:
        
        .. code-block:: python

            #!python
            import theano
            from theano import tensor
            
            a = tensor.constant(1.5)        # declare a symbolic constant
            b = tensor.fscalar()            # declare a symbolic floating-point scalar
            
            c = a + b                       # create a simple expression
            
            f = theano.function([b], [c])   # this works because a has a value associated with it already
            
            assert 4.0 == f(2.5)[0]         # bind 2.5 to an internal copy of b and evaluate an internal c
            
            theano.function([a], [c])       # compilation error because b (required by c) is undefined
            
            theano.function([a,b], [c])     # compilation error because a is constant, it can't be an input
            
            d = tensor.value(1.5)           # create a value similar to the constant 'a'
            e = d + b
            theano.function([d,b], [e])     # this works.  d's default value of 1.5 is ignored.
        
        The python variables ``a,b,c`` all refer to instances of type Result.
        The Result refered to by ``a`` is also an instance of ``Constant``.
        
        Theano.:term:`function` uses the :term:`Apply` instances' ``inputs`` field together with each Result's ``owner`` field to determine which inputs are necessary to compute the function's outputs.
        
        
    Scalar
        [overloaded term]
        
        The scalar we use in the :ref:`tutorial` is a zero-dimensional tensor.
        
        The second type of scalar is for advanced users and developers.
        It is actually a scalar, and is the primitive that is contained by a tensor.
        
        WRITEME: More information.
        
    Stabilization
        graph transformation for numeric stability
        
        Some graph transformations improve numerical stability.  For example ``log(x+1)`` has a special implementation which is accurate for a wider range of ``x`` values than a naive implementation in which ``log`` is applied to a temporary variable storing ``1+x``.  Theano includes many graph transformations aimed at recognizing patterns like this one and replacing them with compound expressions.
        
        Stabilizations are like :term:`optimizations <Optimization>` in the sense that they are often pattern-based sub-graph substitutions.
        
        Stabilizations are unlike :term:`optimizations <Optimization>` in that 
         - they are typically applied even when intermediate results in the subgraph have external :term:`clients`,
         - they are typically prioritized over transformations which improve run-time speed, and
         - they are typically not faster than the naive implementation.
        
    Tensor
        Type for vectors, matrices, etc.
        
        Tensor (`Tensor API <http://lgcm.iro.umontreal.ca/epydoc/theano.tensor.Tensor-class.html doc>`_) is a class
        that derives from :term:`Type`.  It is the symbolic type for ``numpy.ndarray``.
        The main properties that distinguish one Tensor instance from another are:

         * ndim - the rank of the tensor
         * :term:`broadcastable <Broadcasting>` - which dimensions are broadcastable
         * :term:`dtype` - what kind of elements will the tensor contain

        See also :term:`TensorResult`.
        
    TensorResult
        :term:`Results <Result>` of type :term:`Tensor` are of class
        TensorResult (`TensorResult API <http://lgcm.iro.umontreal.ca/epydoc/theano.tensor.TensorResult-class.html>`_).
        ``TensorResult`` adds operator overloading so that ``TensorResult`` instances can be used
        in mathematical expressions.  When any input to an expression is a ``TensorResult`` then the
        expression will evaluate to an ``TensorResult`` and a :term:`graph` corresponding to
        the expression.
        
        Many shortcuts exist for creating ``TensorResult`` instances:

         * ``<t>scalar`` - create a tensor of rank 0
         * ``<t>vector`` - create a tensor of rank 1
         * ``<t>matrix`` - create a tensor of rank 2
         * ``<t>row`` - create a "row vector" (tensor of rank 2) that is :term:`broadcastable <Broadcasting>` over rows
         * ``<t>col`` - create a "column vector" (tensor of rank 2) that is :term:`broadcastable <Broadcasting>` over columns

        In each shortcut the ``<t>`` is a letter from ``fdbil`` that indicates the :term:`DType` 
        of the tensor:

         * ``f`` - float
         * ``d`` - double
         * ``b`` - byte
         * ``i`` - int
         * ``l`` - long
        

    TTI 
        An object instance whose type is a subclass of :term:`Type` is a theano type instance (TTI).
        In the following code:

        .. code-block:: python

            # tensor.fvector is a TTI
            # declare a symbolic floating-point vector using __call__
            b = tensor.fvector()
        
            # create a second Result with the same TTI
            c = tensor.fvector()

        (``tensor.fvector``) is a TTI because
        (``tensor.fvector``) is an instance of the (``theano.tensor.Tensor``) class, which is a subclass of (``theano.Type``).
        
        Whenever you create a variable in theano (technically, a :term:`Result`)  it will contain a reference to a TTI.
        That reference is typically constant during the lifetime of the Result.
        Many variables can refer to a single TTI, as do ``b`` and ``c`` above.
        The TTI defines the kind of value which might end up in that variable when executing a :term:`function`.
        In this sense, theano is like a strongly-typed language.
        In our example above, ``b`` is a result which is guaranteed to corresond to a ``numpy.ndarray`` of rank 1 when we try to do some computations with it.
        
        Many :term:`Ops <Op>` will raise an exception if their inputs do not have the correct types (TTI references).
        TTI references are also useful to do type-checking in pattern-based optimizations.
        
    Type
        :term:`Results <Result>` are strongly typed by :term:`Type` instances
        
        `theano.Type <http://lgcm.iro.umontreal.ca/epydoc/theano.gof.type.Type-class.html>`_
        is an important abstract class in the creation and compilation of theano graphs.
        
        Type instances are mainly responsible for two things: 

         * filtering potential values to conform to the restrictions imposed by the type (also known as casting),
         * creating :term:`Result` instances whose type is ``self`` (conventionally, ``__call__`` does this), and
         * providing the C code that interfaces python objects with C :term:`Op` implementations.
        
        Theano comes with several subclasses of ``theano.type`` such as:

         * Generic (`Generic API <http://lgcm.iro.umontreal.ca/epydoc/theano.gof.type.Generic-class.html>`_) - for any python type
         * :term:`Tensor` - for numpy.ndarray
         * Sparse (`Sparse API <http://lgcm.iro.umontreal.ca/epydoc/theano.sparse.Sparse-class.html>`_) - for scipy.sparse

        You can create more type instances if you like (see :ref:`HowtoCreateType`).
        
        The C code interface methods of
        ``theano.Type`` are described in `docstrings
        <http://lgcm.iro.umontreal.ca/epydoc/theano.gof.type.Type-class.html>`_,
        see :ref:`CodeGeneration` for a more general intro to how C code is generated.

        See also :term:`Theano type instance (TTI) <TTI>`.

        See :ref:`intro_to_types`.
        

    Value
        :term:`Value` (`Value API <http://lgcm.iro.umontreal.ca/epydoc/theano.gof.graph.Value-class.html doc>`_)
        and :term:`Constant` are subclasses of
        :term:`Result`, which means they serve more or less the
        same purpose. There is however one important difference:
        whereas :term:`Result` is purely symbolic, :term:`Value` and
        :term:`Constant` can hold data in their ``data`` pointer and
        ''must'' have a ''None'' owner (can't be the result of some other
        Theano computation). This can be practical because the compiler
        knows how to assign values to those nodes, thereby creating a
        sort of closure.
..
