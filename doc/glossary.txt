.. _glossary:

Glossary of terminology
=======================

.. glossary::

    Apply
        Instances of :class:`Apply` represent the application of an :term:`Op`
        to some input :term:`Variable`s to produce some output
        :term:`Variable`s.  They are like the application of a [symbolic]
        mathematical function to some [symbolic] inputs.

    Broadcasting
        Broadcasting is a mechanism which allows tensors with
        different numbers of dimensions to be used in element-by-element
        (elementwise) computations.  It works by
        (virtually) replicating the smaller tensor along
        the dimensions that it is lacking.  
        
        For more detail, see :ref:`libdoc_tensor_broadcastable`, and also
        * `SciPy documentation about numpy's broadcasting <http://www.scipy.org/EricsBroadcastingDoc>`_
        * `OnLamp article about numpy's broadcasting <http://www.onlamp.com/pub/a/python/2000/09/27/numerically.html>`_

    Constant
        A variable with an immutable value.
        For example, when you type
        >>> x = tensor.ivector()
        >>> y = x + 3
        Then a `constant` is created to represent the ``3`` in the graph.

        See also: :class:`gof.Constant`


    Elementwise
        An elementwise operation ``f`` on two matrices ``M`` and ``N``
        is one such that:

        ``f(M, N)[i, j] = f(M[i, j], N[i, j])``

        In other words, each element of an input matrix is combined
        with the corresponding element of the other(s). There are no
        dependencies between elements whose ``[i, j]`` coordinates do
        not correspond, so an elementwise operation is like a scalar
        operation generalized along several dimensions.

        There exist unary, binary, ternary, etc. elementwise
        operations and they can work on scalars, vectors, matrices,
        etc. as long as all the inputs have the same dimensions or can
        be :term:`broadcasted <broadcasting>` to the same dimensions.

        Examples of elementwise operations in Theano: ``add, sub, mul,
        div, neg, inv, log, exp, sin, cos, tan`` and many
        others. These operations are all instances of :api:`Elemwise
        <theano.tensor.elemwise.Elemwise>`.

    Expression
        See :term:`Apply`

    Expression Graph
        A directed, acyclic set of connected :term:`Variable` and
        :term:`Apply` nodes that express symbolic functional relationship
        between variables.  You use Theano by defining expression graphs, and
        then compiling them with :term:`theano.function`.

        See also :term:`Variable`, :term:`Op`, :term:`Apply`, and
        :term:`Type`, or read more about :ref:`tutorial_graphstructures`.

    Destructive
        An :term:`Op` is destructive (of particular input[s]) if its
        computation requires that one or more inputs be overwritten or
        otherwise invalidated.  For example, :term:`inplace` Ops are
        destructive.  Destructive Ops can sometimes be faster than
        non-destructive alternatives.  Theano encourages users not to put
        destructive Ops into graphs that are given to :term:`theano.function`,
        but instead to trust the optimizations to insert destructive ops
        judiciously.

        Destructive Ops are indicated via a ``destroy_map`` Op attribute. (See
        :class:`gof.Op`.


    Graph 
        see :term:`expression graph`

    Inplace
        Inplace computations are computations that destroy their inputs as a
        side-effect.  For example, if you iterate over a matrix and double
        every element, this is an inplace operation because when you are done,
        the original input has been overwritten.  Ops representing inplace
        computations are :term:`destructive`, and by default these can only be
        inserted by optimizations, not user code.

    Linker
        Part of a function :term:`Mode` -- an object responsible for 'running'
        the compiled function.  Among other things, the linker determines whether computations are carried out with C or Python code.
        
    Merge
        A simple optimization in which redundant :term:`Apply` nodes are
        combined.  For example, in ``function([x,y], [(x+y)*2, (x+y)*3])`` the merge
        optimization will ensure that ``x`` and ``y`` are only added once.

    Mode 
        An object providing an :term:`optimizer` and a :term:`linker` that is
        passed to :term:`theano.funcion`.  It parametrizes how an expression
        graph is converted to a callable object.

    Op
        The ``.op`` of an :term:`Apply`, together with its symbolic inputs
        fully determines what kind of computation will be carried out for that
        ``Apply`` at run-time.  Mathematical functions such as addition
        (``T.add``) and indexing  ``x[i]`` are Ops in Theano.  Much of the
        library documentation is devoted to describing the various Ops that
        are provided with Theano, but you can add more.

        See also :term:`Variable`, :term:`Type`, and :term:`Apply`, 
        or read more about :ref:`tutorial_graphstructures`.

    Optimizer
        An instance of :class:`Optimizer`, which has the capacity to provide
        :term:`optimization`s.

    Optimization
        A :term:`graph` transformation applied by an :term:`optimizer` during
        the compilation of a :term:`graph` by :term:`theano.function`.

    Storage
        The memory that is used to store the value of a Variable.  In most
        cases storage is internal to a compiled function, but in some cases
        (such as :term:`constant` and :term:`shared variable <shared variable>` the storage is not internal.

    Shared Variable
        A :term:`Variable` whose value may be shared between multiple functions.  See :func:`shared` and :func:`theano.function <function.function>`.

    theano.function
        The interface for Theano's compilation from symbolic expression graphs
        to callable objects.  See :func:`function.function'.

    Type
        The ``.type`` of a
        :term:`Variable` indicates what kinds of values might be computed for it in a
        compiled graph.
        An instance that inherits from :class:`Type`, and is used as the
        ``.type`` attribute of a :term:`Variable`.  

        See also :term:`Variable`, :term:`Op`, and :term:`Apply`, 
        or read more about :ref:`tutorial_graphstructures`.

    Variable
        The the main data structure you work with when using Theano.
        For example,

        >>> x = theano.tensor.ivector()
        >>> y = -x**2

        ``x`` and ``y`` are both `Variables`, i.e. instances of the :class:`Variable` class.

        See also :term:`Type`, :term:`Op`, and :term:`Apply`, 
        or read more about :ref:`tutorial_graphstructures`.

    View
        Some Tensor Ops (such as Subtensor and Transpose) can be computed in
        constant time by simply re-indexing their inputs.   The outputs from
        [the Apply instances from] such Ops are called `Views` because their
        storage might be aliased to the storage of other variables (the inputs
        of the Apply).  It is important for Theano to know which Variables are
        views of which other ones in order to introduce :term:`Destructive`
        Ops correctly.

        View Ops are indicated via a ``view_map`` Op attribute. (See
        :class:`gof.Op`.







































..
    Apply
        TRANSFERRED
        
    Broadcasting
        TRANSFERRED
        
    Build
        see :term:`Compilation`
        
    Compilation
        use a mode to transform graph into a callable
        
        Compilation is the transformation of a graph into a callable object instance.
        Compilation is implemented by the :ref:`theano.function() <CompileFunction>` function.
        
        As far as compilation is concerned, ``theano.function()`` accepts three important arguments: a list of inputs, a list of outputs, and a :term:`mode`:
            #. use ``owner`` and ``input`` fields to identify the intermediate nodes connecting inputs to outputs
            #. copy that sub-graph into an internal :term:`Env` instance
            #. use the Env to transform the subgraph copy (introduce :term:`optimizations <Optimization>` and :term:`stabilizations <Stabilization>`)
            #. serialize the transformed subgraph by topological sort
            #. allocate a :term:`linker` to perform the calculations associated with each :term:`Op`.
        
        The :term:`mode` defines how optimizations and stabilizations will be introduced, and defines which linker will be used.

    Constant
        TRANSFERRED    

    DType
        the numeric type for :term:`Tensor` elements

        A :term:`Tensor` is for storing a number of objects that
        all have the same type.  In computations, the storage for
        :term:`TensorVariable` instances is a ``numpy.ndarray``.
        Instances of ``numpy.ndarray`` have a ``dtype`` property
        to indicate which data type (i.e., byte, float, double, python
        object) can be stored in each element.  The ``dtype`` property
        of Tensors is a little different: it is a string which can be
        converted to a numpy ``dtype`` object.  Still the meaning
        is pretty much the same: elements of the ``numpy.ndarray``
        corresponding to a :term:`TensorVariable` in a particular
        computation must have the corresponding data type.


    Env
        important class during compilation

        WRITEME

    Function
        callable object representing a compiled graph

        It is created through ``theano.function``.

        WRITEME

    Graph
        TRANSFERRED


    Graph Transformation
        compilation stage

        :term:`Env`, in particular `replace()
        <http://pylearn.org/epydoc/theano.gof.env.Env-class.html#replace
        replace()>`_

        See also `Optimizer
        <http://pylearn.org/epydoc/theano.gof.opt.Optimizer-class.html>`_,
        which is the base interface for writing transformers, such as
        :term:`optimizations <Optimization>` and :term:`stabilizations
        <Stabilization>`.

        WRITEME

    Linker
        object which executes serialized graphs after compilation

        WRITEME

    Mode
        mode of compilation (linker, transformer)

        WRITEME

    Module
        See :ref:`Module`.

    Op
        a type of operation. Instance is TOI

        :term:`Op` is an abstract class (`Op API
        <http://pylearn.org/epydoc/theano.gof.op.Op-class.html>`_)
        that documents the interface for theano's data
        transformations.  It has many subclasses, such as `sparse Dot
        <http://pylearn.org/epydoc/theano.sparse.Dot-class.html>`_.
        and `Shape
        <http://pylearn.org/epydoc/theano.tensor.Shape-class.html>`_.


        Comparing with the Python language, :term:`Op` is theano's
        version of a function definition where an :term:`Apply` instance
        is theano's version of a function call (or expression instance).

        These subclasses are meant to be instantiated, and I'll call
        an instance a theano Op instance (TOI).  A TOI has several
        important responsabilities:

            * making :term:`Apply` instances, which mean "apply this TOI to some particular inputs" (via the ``make_node``),
            * performing the calculation of outputs from given inputs (via the ``perform``),
            * producing c code to perform calculation of outputs from inputs (via ``c_code, c_code_cleanup, c_support_code, c_headers, c_libraries, c_compile_args, c_no_compile_args``)
            * [optionally] building gradient-calculating graphs (via ``grad``).

        See :ref:`intro_to_ops`.
        
    Optimization
        graph transformation for faster execution
        
        An optimization is a type of :term:`graph transformation`.
        
        WRITEME.
        
    Variable
        a Type-related graph node (a variable)
        
        A Variable
        (`Variable API <http://pylearn.org/epydoc/theano.gof.graph.Variable-class.html>`_)
        is theano's variable.  It symbolically represents a value (which
        can be a number, vector, matrix, tensor, etc.).
        The inputs and outputs of every :term:`Op` are Variable instances.
        The input and output arguments to create a :term:`function` are also Variables.
        A Variable is like a strongly-typed variable in some other languages; each Variable contains a reference to a :term:`TTI` (Theano Type Instance) that defines the kind of value that can be associated to the Variable by a :term:`function`.
        
        A Variable is a container for four important fields:
            type
                a :term:`TTI` defining the kind of value this Variable can have,
            owner
                either None (for graph roots) or the :term:`Apply` instance (i.e. variable of applying an :term:`Op`) of which ``self`` is an output,
            index
                the integer such that ``owner.outputs[index] is this_variable`` (ignored if ``owner`` is None)
            name
                a string to use in pretty-printing and debugging.
        
        There are two subclasses related to Variable:
            :term:`Value`
                a Variable with a data field.
            :term:`Constant`
                like ``Value``, but the data it contains cannot be modified.

        See :ref:`intro_to_types`.
        
        Code Example:
        
        .. code-block:: python

            #!python
            import theano
            from theano import tensor
            
            a = tensor.constant(1.5)        # declare a symbolic constant
            b = tensor.fscalar()            # declare a symbolic floating-point scalar
            
            c = a + b                       # create a simple expression
            
            f = theano.function([b], [c])   # this works because a has a value associated with it already
            
            assert 4.0 == f(2.5)[0]         # bind 2.5 to an internal copy of b and evaluate an internal c
            
            theano.function([a], [c])       # compilation error because b (required by c) is undefined
            
            theano.function([a,b], [c])     # compilation error because a is constant, it can't be an input
            
            d = tensor.value(1.5)           # create a value similar to the constant 'a'
            e = d + b
            theano.function([d,b], [e])     # this works.  d's default value of 1.5 is ignored.
        
        The python variables ``a,b,c`` all refer to instances of type Variable.
        The Variable refered to by ``a`` is also an instance of ``Constant``.
        
        Theano.:term:`function` uses the :term:`Apply` instances' ``inputs`` field together with each Variable's ``owner`` field to determine which inputs are necessary to compute the function's outputs.
        
        
    Scalar
        [overloaded term]
        
        The scalar we use in the :ref:`tutorial` is a zero-dimensional tensor.
        
        The second type of scalar is for advanced users and developers.
        It is actually a scalar, and is the primitive that is contained by a tensor.
        
        WRITEME: More information.
        
    Stabilization
        graph transformation for numeric stability
        
        Some graph transformations improve numerical stability.  For example ``log(x+1)`` has a special implementation which is accurate for a wider range of ``x`` values than a naive implementation in which ``log`` is applied to a temporary variable storing ``1+x``.  Theano includes many graph transformations aimed at recognizing patterns like this one and replacing them with compound expressions.
        
        Stabilizations are like :term:`optimizations <Optimization>` in the sense that they are often pattern-based sub-graph substitutions.
        
        Stabilizations are unlike :term:`optimizations <Optimization>` in that 
         - they are typically applied even when intermediate variables in the subgraph have external :term:`clients`,
         - they are typically prioritized over transformations which improve run-time speed, and
         - they are typically not faster than the naive implementation.
        
    Tensor
        Type for vectors, matrices, etc.
        
        Tensor (`Tensor API <http://pylearn.org/epydoc/theano.tensor.Tensor-class.html doc>`_) is a class
        that derives from :term:`Type`.  It is the symbolic type for ``numpy.ndarray``.
        The main properties that distinguish one Tensor instance from another are:

         * ndim - the rank of the tensor
         * :term:`broadcastable <Broadcasting>` - which dimensions are broadcastable
         * :term:`dtype` - what kind of elements will the tensor contain

        See also :term:`TensorVariable`.
        
    TensorVariable
        :term:`Variables <Variable>` of type :term:`Tensor` are of class
        TensorVariable (`TensorVariable API <http://pylearn.org/epydoc/theano.tensor.TensorVariable-class.html>`_).
        ``TensorVariable`` adds operator overloading so that ``TensorVariable`` instances can be used
        in mathematical expressions.  When any input to an expression is a ``TensorVariable`` then the
        expression will evaluate to an ``TensorVariable`` and a :term:`graph` corresponding to
        the expression.
        
        Many shortcuts exist for creating ``TensorVariable`` instances:

         * ``<t>scalar`` - create a tensor of rank 0
         * ``<t>vector`` - create a tensor of rank 1
         * ``<t>matrix`` - create a tensor of rank 2
         * ``<t>row`` - create a "row vector" (tensor of rank 2) that is :term:`broadcastable <Broadcasting>` over rows
         * ``<t>col`` - create a "column vector" (tensor of rank 2) that is :term:`broadcastable <Broadcasting>` over columns

        In each shortcut the ``<t>`` is a letter from ``fdbil`` that indicates the :term:`DType` 
        of the tensor:

         * ``f`` - float
         * ``d`` - double
         * ``b`` - byte
         * ``i`` - int
         * ``l`` - long
        

    TTI 
        An object instance whose type is a subclass of :term:`Type` is a theano type instance (TTI).
        In the following code:

        .. code-block:: python

            # tensor.fvector is a TTI
            # declare a symbolic floating-point vector using __call__
            b = tensor.fvector()
        
            # create a second Variable with the same TTI
            c = tensor.fvector()

        (``tensor.fvector``) is a TTI because
        (``tensor.fvector``) is an instance of the (``theano.tensor.Tensor``) class, which is a subclass of (``theano.Type``).
        
        Whenever you create a variable in theano (technically, a :term:`Variable`)  it will contain a reference to a TTI.
        That reference is typically constant during the lifetime of the Variable.
        Many variables can refer to a single TTI, as do ``b`` and ``c`` above.
        The TTI defines the kind of value which might end up in that variable when executing a :term:`function`.
        In this sense, theano is like a strongly-typed language.
        In our example above, ``b`` is a variable which is guaranteed to corresond to a ``numpy.ndarray`` of rank 1 when we try to do some computations with it.
        
        Many :term:`Ops <Op>` will raise an exception if their inputs do not have the correct types (TTI references).
        TTI references are also useful to do type-checking in pattern-based optimizations.
        
    Type
        :term:`Variables <Variable>` are strongly typed by :term:`Type` instances
        
        `theano.Type <http://pylearn.org/epydoc/theano.gof.type.Type-class.html>`_
        is an important abstract class in the creation and compilation of theano graphs.
        
        Type instances are mainly responsible for two things: 

         * filtering potential values to conform to the restrictions imposed by the type (also known as casting),
         * creating :term:`Variable` instances whose type is ``self`` (conventionally, ``__call__`` does this), and
         * providing the C code that interfaces python objects with C :term:`Op` implementations.
        
        Theano comes with several subclasses of ``theano.type`` such as:

         * Generic (`Generic API <http://pylearn.org/epydoc/theano.gof.type.Generic-class.html>`_) - for any python type
         * :term:`Tensor` - for numpy.ndarray
         * Sparse (`Sparse API <http://pylearn.org/epydoc/theano.sparse.Sparse-class.html>`_) - for scipy.sparse

        You can create more type instances if you like (see :ref:`HowtoCreateType`).
        
        The C code interface methods of
        ``theano.Type`` are described in `docstrings
        <http://pylearn.org/epydoc/theano.gof.type.Type-class.html>`_,
        see :ref:`CodeGeneration` for a more general intro to how C code is generated.

        See also :term:`Theano type instance (TTI) <TTI>`.

        See :ref:`intro_to_types`.
        

    Value
        :term:`Value` (`Value API <http://pylearn.org/epydoc/theano.gof.graph.Value-class.html doc>`_)
        and :term:`Constant` are subclasses of
        :term:`Variable`, which means they serve more or less the
        same purpose. There is however one important difference:
        whereas :term:`Variable` is purely symbolic, :term:`Value` and
        :term:`Constant` can hold data in their ``data`` pointer and
        ''must'' have a ''None'' owner (can't be the variable of some other
        Theano computation). This can be practical because the compiler
        knows how to assign values to those nodes, thereby creating a
        sort of closure.
..
