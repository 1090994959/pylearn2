
=====
Tools
=====


Mode
====

WRITEME

.. _tensortypes:

Types
=====

NOTE: I'm not sure this actually goes in the tutorial - it ended up
much longer than intended - maybe we should just link to it! --OB

.. _predefinedtypes:

Predefined types
----------------

Theano gives you many premade types to work with. These types are
located in the ``theano.tensor`` package. The name of the types follow
a recipe:

``<dtype><dimensionality>``

Where ``<dtype>`` is one of:

==== ======== ============== ====
code type     domain         bits
==== ======== ============== ====
b    byte     signed integer 8
w    word     signed integer 16
i    integer  signed integer 32
l    long     signed integer 64
f    float    floating point 32
d    double   floating point 64
==== ======== ============== ====

Dimensionality is one of:

====== ====== ========================================== =============================================
code   shape  Rows :term:`broadcastable <broadcasting>`? Columns :term:`broadcastable <broadcasting>`?
====== ====== ========================================== =============================================
scalar []     Yes                                        Yes
vector [n]    Yes                                        N/A (vectors are used like row vectors)
row    [1, n] Yes                                        No
col    [m, 1] No                                         Yes
matrix [m, n] No                                         No
====== ====== ========================================== =============================================

So for example if you want a row of 32-bit floats, it is available
under ``theano.tensor.frow`` and if you want a matrix of unsigned
32-bit integers it is available under ``theano.tensor.imatrix``.

Each of the types described above can be constructed by two methods:
a singular version (e.g., ``dmatrix``) and a plural version
(``dmatrices``).  When called, the singular version takes a single
argument which is the name of the :term:`Result` we want to make and it
makes a single Result of that type. The plural version can either take
an integer or several strings. If an integer is provided, the method
will return that many Results and if strings are provided, it will
create one Result for each string, using the string as the Result's
name. For example:

.. code-block:: python

   from theano.tensor import *

   x = dmatrix() # creates one Result with no name
   x = dmatrix('x') # creates one Result with name 'x'
   xyz = dmatrix('xyz') # creates one Result with name 'xyz'

   x, y, z = dmatrices(3) # creates three Results with no names
   x, y, z = dmatrices('x', 'y', 'z') # creates three Results named 'x', 'y' and 'z'


Custom tensor types
-------------------

If you wish to use a type of tensor which is not already available here
(for example, a 3D tensor) you can build an appropriate type using
``theano.tensor.Tensor``. The first argument you pass is the ``dtype``
and the second is the ``broadcastable pattern``.

Where ``dtype`` is one of:

=========== ================ =================
dtype       domain           bits
=========== ================ =================
int8        signed integer   8
int16       signed integer   16
int32       signed integer   32
int64       signed integer   64
uint8       unsigned integer 8
uint16      unsigned integer 16
uint32      unsigned integer 32
uint64      unsigned integer 64
float32     floating point   32
float64     floating point   64
complex64   complex          64 (two float32)
complex128  complex          128 (two float64)
=========== ================ =================

.. note::

   Even though ``theano.tensor`` does not define any type using
   ``complex`` dtypes (``complex64`` or ``complex128``), you can define
   them explicitly with ``Tensor`` (see example below). However, few
   operations are fully supported for complex types: as of version 0.1,
   only elementary operations (``+-*/``) have C implementations.


The broadcastable pattern, on the other hand, indicates both the
number of dimensions and whether a particular dimension has length
1. Here is a handy table mapping the :term:`broadcastable
<broadcasting>` pattern to what kind of tensor it encodes:

===================== =================================
pattern               interpretation
===================== =================================
[]                    scalar
[True]                1D scalar (vector of length 1)
[True, True]          2D scalar (1x1 matrix)
[False]               vector
[False, False]        matrix
[False] * n           nD tensor
[True, False]         row (1xN matrix)
[False, True]         column (Mx1 matrix)
[False, True, False]  A Mx1xP tensor (a)
[True, False, False]  A 1xNxP tensor (b)
[False, False, False] A MxNxP tensor (pattern of a + b)
===================== =================================

When two tensors have a different number of dimensions, the broadcastable
pattern is *expanded to the left*, by padding with ``True``. So, for example,
a vector's pattern, ``[False]``, could be expanded to ``[True, False]``, and
would behave like a row (1xN matrix). In the same way, a matrix (``[False,
False]``) would behave like a 1xNxP tensor (``[True, False, False]``).

So if we wanted to create a type representing a 3D array of unsigned
bytes, we would simply do: 

.. code-block:: python

   # 3D tensor of signed bytes
   mytype = theano.tensor.Tensor('uint8', [False]*3)

   # complex types (based on complex64)
   my_cscalar = theano.tensor.Tensor('complex64', [])
   my_cmatrix = theano.tensor.Tensor('complex64', [False, False])


Ops
===

There's a lot of operations readily available in the ``theano.tensor``
package. They do not require much explanation according to this
tutorial's author, so he will simply direct you to the :ref:`oplist`
:)



**Next:** `Wrapping up`_

.. _Wrapping up: wrapup.html





