
=====
Tools
=====


Mode
====

WRITEME

.. _tensortypes:

Types
=====

NOTE: I'm not sure this actually goes in the tutorial - it ended up
much longer than intended - maybe we should just link to it! --OB

.. _predefinedtypes:

Predefined types
----------------

Predefined types are
located in the ``theano.tensor`` package. The name of the types follow
a recipe:

``<dtype><dimensionality>``

Where ``<dtype>`` is one of:

==== ======== ============== ====
code type     domain         bits
==== ======== ============== ====
b    byte     signed integer 8
w    word     signed integer 16
i    integer  signed integer 32
l    long     signed integer 64
f    float    floating point 32
d    double   floating point 64
==== ======== ============== ====

Dimensionality is one of:

====== ====== ========================================== =============================================
code   shape  Rows :term:`broadcastable <broadcasting>`? Columns :term:`broadcastable <broadcasting>`?
====== ====== ========================================== =============================================
scalar []     Yes                                        Yes
vector [n]    Yes                                        N/A (vectors are used like row vectors)
row    [1, n] Yes                                        No
col    [m, 1] No                                         Yes
matrix [m, n] No                                         No
====== ====== ========================================== =============================================

So, if you want a row of 32-bit floats, it is available
as ``theano.tensor.frow``. If you want a matrix of unsigned
32-bit integers it is available as ``theano.tensor.imatrix``.

Each of the types described above can be constructed by two methods:
a singular version (e.g., ``dmatrix``) and a plural version
(``dmatrices``).  When called, the singular version takes a single
argument which is the name of the :term:`Result` we want to make and it
makes a single Result of that type. The plural version can either take
an integer or several strings. If an integer is provided, the method
will return that many Results and if strings are provided, it will
create one Result for each string, using the string as the Result's
name. For example:

.. code-block:: python

   from theano.tensor import *

   x = dmatrix() # creates one Result with no name
   x = dmatrix('x') # creates one Result with name 'x'
   xyz = dmatrix('xyz') # creates one Result with name 'xyz'

   x, y, z = dmatrices(3) # creates three Results with no names
   x, y, z = dmatrices('x', 'y', 'z') # creates three Results named 'x', 'y' and 'z'


Custom tensor types
-------------------

If you wish to use a type of tensor which is not already available here
(for example, a 3D tensor) you can build an appropriate type using
``theano.tensor.NDArrayType``. The first argument you pass is the ``dtype``
and the second is the ``broadcastable pattern``.

Where ``dtype`` is one of:

=========== ================ =================
dtype       domain           bits
=========== ================ =================
int8        signed integer   8
int16       signed integer   16
int32       signed integer   32
int64       signed integer   64
uint8       unsigned integer 8
uint16      unsigned integer 16
uint32      unsigned integer 32
uint64      unsigned integer 64
float32     floating point   32
float64     floating point   64
complex64   complex          64 (two float32)
complex128  complex          128 (two float64)
=========== ================ =================

.. note::

   Even though ``theano.tensor`` does not define any type
   using ``complex`` dtypes (``complex64`` or ``complex128``),
   you can define them explicitly with ``NDArrayType`` (see example
   below). However, few operations are fully supported for complex
   types: as of version 0.1, only elementary operations (``+-*/``)
   have C implementations. Additionally, complex types have received
   little testing.


The broadcastable pattern indicates both the number of dimensions and
whether a particular dimension must have length 1.
Here is a table mapping the :term:`broadcastable
<broadcasting>` pattern to what kind of tensor it encodes:

===================== =================================
pattern               interpretation
===================== =================================
[]                    scalar
[True]                1D scalar (vector of length 1)
[True, True]          2D scalar (1x1 matrix)
[False]               vector
[False, False]        matrix
[False] * n           nD tensor
[True, False]         row (1xN matrix)
[False, True]         column (Mx1 matrix)
[False, True, False]  A Mx1xP tensor (a)
[True, False, False]  A 1xNxP tensor (b)
[False, False, False] A MxNxP tensor (pattern of a + b)
===================== =================================

For dimensions in which broadcasting is False, the length of this
dimension can be 1 or more.  For dimensions in which broadcasting is True,
the length of this dimension must be 1.

When two tensors have a different number of dimensions, the broadcastable
pattern is *expanded to the left*, by padding with ``True``. For example,
a vector's pattern, ``[False]``, could be expanded to ``[True, False]``, and
would behave like a row (1xN matrix). In the same way, a matrix (``[False,
False]``) would behave like a 1xNxP tensor (``[True, False, False]``).

If we wanted to create a type representing a 3D array of unsigned
bytes, we would do: 

.. code-block:: python

   # 3D tensor of signed bytes
   mytype = theano.tensor.NDArrayType('uint8', [False]*3)

   # complex types (based on complex64)
   my_cscalar = theano.tensor.NDArrayType('complex64', [])
   my_cmatrix = theano.tensor.NDArrayType('complex64', [False, False])


Ops
===

There are a lot of operations available in the ``theano.tensor`` package.
See :ref:`oplist`.



**Next:** `Wrapping up`_

.. _Wrapping up: wrapup.html





