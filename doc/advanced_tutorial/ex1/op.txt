
===============================
Making arithmetic Ops on double
===============================

Now that we have a ``double`` type, we have yet to use it to perform
computations. We'll start by defining multiplication.


Op's contract
=============

An Op is any object which defines the following methods:

- **make_node(*inputs)**
    
  - This method is responsible for creating output Results of a suitable Type
    to serve as the outputs of this Op's application.  It should put these
    outputs into an Apply instance, and return the Apply instance.
  
  - This important function creates an Apply node representing the
    application of the Op on the inputs provided. If the Op cannot be
    applied on these inputs, it must raise an appropriate
    exception.

  - The inputs of the Apply instance returned by this call must be ordered
    correctly: a subsequent ``self.make_node(*apply.inputs)`` must produce
    something equivalent to the first ``apply``.

- **__call__(*inputs)**

  - Syntactic shortcut to make_node which returns the output Results
    of the Op.

  - *Default*: this is done for you by Op.

- **perform(node, inputs, output_storage)**

  - This function computes the function associated to this Op. The
    ``node`` is an Apply node created by the Op's ``make_node``
    method, the inputs are a list of references to data to operate on
    and output_storage is a list of storage cells where the results of
    the computation must be put.
  
  - This function must be determined by the inputs.  That is to say, if it is
    evaluated once on inputs A and returned B, then if ever inputs C, equal to
    A, are presented again, then outputs equal to B must be returned again.
  
  - You must be careful about aliasing outputs to inputs, and making
    modifications to any of the inputs.  See `Views and inplace operations`_
    before writing a ``perform`` implementation that does either of these
    things.

- **__eq__(self, other)**

  - Returning True here is a promise to the optimization system that the other
    Op will produce exactly the same graph effects (from perform) as this one,
    given identical inputs.  This means it will produce the same output values,
    it will destroy the same inputs (same destroy_map), and will alias outputs
    to the same inputs (same view_map).

- **__hash__(self)**

  - If two Op instances compare equal, then they MUST return the same hash
    value.  
      
  - Equally important, this hash value must not change during the lifetime of
    self.

- **__ne__(self, other)**

  - Recommended, and default: define as (not (self==other))

- **grad(inputs, output_gradients)** *Optional*

  - If the Op you are defining is differentiable, you can define its
    gradient symbolically in this method. 
    
  - Both the inputs and output_gradients will be Results. This function must
    return a list containing one Result (or None) for each input.
    Each returned Result represents the gradient wrt that input given the
    symbolic gradients wrt each output.

  - If the output is not differentiable with respect to any inputs, then this
    function should be defined to return [None for i in inputs].

  - If this method is not defined, then theano assumes it has been forgotten.
    Symbolic differentiation will fail on a graph that includes this Op.

  - For more information on the use of this method, see ``grad``.


For each method, the *default* is what the Op class defines for you.

For more details, including the interface for providing a C implementation of
perform(), refer to the documentation for :ref:`op`.


Checklist
---------

Use this list to make sure that you defined everything you need for your Op:
  * Are there parameters that are not inputs but parametrize the behavior of your Op? (see parametrization section below)

    * Yes?

      * Define ``__init__`` with those parameters. They will be instance variables.
      * Override ``__eq__``, ``__ne__`` and ``__hash__`` (optional)
      * Consider making pre-made instances for common parameters. This will simplify usage.
    * No? (usual case for simple Ops)

      * Consider making a singleton of your Op (this can be as simple as ``my_op = MyOp()``). It will simplify usage. [*What is the benefit of using the singleton? How does it simplify usage? We __shouldn't__ use singletons when there __are__ parameters?*]
      * All instances should compare equal (which is trivial if there is only one of them). [*How do we make sure this is true? Because this checklist should be a list of instructions. Do you describe later on?*]
  * Always define *make_node* (see make_node section below).
  * Always define *perform* (see perform section below).
  * Do you need performance only C can offer?

    * Define *c_code* and *c_code_cleanup* (see HowtoMakeCeeOps)
    * Remember to use the 'c' or 'c|py' linker on graphs using your Op! [*This is described where?*]
  * Is your Op differentiable?

    * Define *grad* (see grad section below) [*If not, and you don't define *grad*, what will happen if you try to differentiate it?*]
  * Does your Op modify any of its inputs?

    * *IMPORTANT:* read the destroyers and viewers section.
  * Does any output from the Op share any sort of state with an input?

    * *IMPORTANT:* read the destroyers and viewers section.
  * Does your Op have more than one output?

    * Consider setting the default_output attribute to the index of that output. (It will make your Op usable in ``PatternOptimizers``, and make user code look like the Op has only that output.)

[*Consider changing the order of the checklist above and the sections below such that the stuff you ALWAYS have to do, which is the most basic stuff anyhow, goes towards the top.*]


Defining mul
============

We are going to redefine the two functions that are absolutely
necessary to redefine: ``make_node`` and ``perform``. First, we'll
instantiate a ``mul`` Op:

.. code-block:: python

   from theano import gof
   mul = gof.Op()


**make_node**

This function must take as many arguments as the operation we are
defining is supposed to take as inputs - in this example that would be
two (we'll define multiplication as a binary operation here, even
though a multiplication Op could technically take an arbitrary number
of arguments). It should ensure that both inputs have the ``double``
type and it should make an Apply node with an output Result of type
``double`` (since multiplying two doubles yields a double).

.. code-block:: python

   def make_node(x, y):
       if x.type != double or y.type != double:
           raise TypeError('mul only works on doubles')
       return gof.Apply(mul, [x, y], [double()])
   mul.make_node = make_node


The first two lines make sure that both inputs are Results of the
``double`` type that we created in the previous section. We would not
want to multiply two arbitrary types, it would not make much sense
(and we'd be screwed when we implement this in C!)

The last line is the meat of the definition. There we create an Apply
node representing the application of ``mul`` to ``x`` and ``y``. Apply
takes three arguments: the first one is the Op we are applying. In
this case, we are applying ``mul``. The second argument is a list of
input Results - here, ``x`` and ``y``. The third is a list of output
Results. Since the multiplication of two doubles ought to give us a
double again, we create a Result of type ``double`` and we place it in
a list. Since the list only has one element, ``mul`` only has one
output.

.. note::
   Theano relies on the fact that if you call the ``make_node`` method
   of Apply's first argument on the inputs passed as the Apply's
   second argument, the call will not fail and the returned Apply
   instance will be equivalent. We can see that this is trivially true
   here.


**perform**

This code should actually compute the function. It is important to
understand the role of all three arguments of ``perform``:

- *node*: This is a reference to an Apply node which was previously
  obtained via ``mul``'s ``make_node`` method. It is not typically
  useful, but it contains symbolic information that could be required
  for complex Ops.

- *inputs*: This is a list of data. In this example, the data in
  ``inputs`` will be instances of Python's built-in type ``float``
  because this is the type that ``double.filter()`` will always
  return, per our own definition.

- *output_storage*: This is a list of storage cells. There is one
  storage cell for each output of the Op. A storage cell is
  a one-element list (note: it is forbidden to change the
  length of the list(s) contained in output_storage). In this example,
  output_storage will contain a single storage cell for the
  multiplication's result.

.. code-block:: python

   def perform(node, inputs, output_storage):
       x, y = inputs[0], inputs[1]
       z = output_storage[0]
       z[0] = x * y
   mul.perform = perform

Here, ``z`` is a list of one element. By default, ``z == [None]``.

.. note::
   It is possible that ``z`` does not contain ``None``. If it contains
   anything else, Theano guarantees that whatever it contains is what
   ``perform`` put there the last time it was called with this
   particular storage. Furthermore, Theano gives you permission to do
   whatever you want with ``z``'s contents, chiefly reusing it or the
   memory allocated for it. More information can be found in the
   :ref:`op` documentation.

.. warning::
   The data you put in ``output_storage`` must match the type of the
   symbolic output. This is a situation where the ``node`` argument
   can come in handy. In this example, we gave ``z`` the Theano type
   ``double`` in ``make_node``, which means that a Python ``float``
   must be put there. You should not put, say, an ``int`` in ``z[0]``
   because Theano assumes Ops handle typing properly.


Trying out our new Op
=====================

In the following code, we use our new Op:

>>> x, y = double('x'), double('y')
>>> z = mul(x, y)
>>> f = theano.function([x, y], z)
>>> f(5, 6)
30.0
>>> f(5.6, 6.7)
37.519999999999996

Note that there is an implicit call to
``double.filter()`` on each argument, so if we give integers as inputs
they are magically casted to the right type. Now, what if we try this?

>>> x = double('x')
>>> z = mul(x, 2)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/u/breuleuo/hg/theano/theano/gof/op.py", line 207, in __call__
  File "<stdin>", line 2, in make_node
AttributeError: 'int' object has no attribute 'type'

Well, ok. We'd like our Op to be a bit more flexible. This can be done
by modifying ``make_node`` to accept Python ``int`` or ``float`` as
``x`` and/or ``y``:

.. code-block:: python

   def make_node(x, y):
       if isinstance(x, (int, float)):
           x = gof.Constant(double, x)
       if isinstance(y, (int, float)):
           y = gof.Constant(double, y)
       if x.type != double or y.type != double:
           raise TypeError('mul only works on doubles')
       return gof.Apply(mul, [x, y], [double()])
   mul.make_node = make_node

Whenever we pass a Python int or float instead of a Result as ``x`` or
``y``, make_node will convert it to :ref:`constant` for us. ``gof.Constant``
is a :ref:`result` we statically know the value of.

>>> x = double('x')
>>> z = mul(x, 2)
>>> f = theano.function([x], z)
>>> f(10)
20.0
>>> f(3.4)
6.7999999999999998

Now the code works the way we want it to.


Final version
=============

The above example is pedagogical.  When you define other basic arithmetic
operations ``add``, ``sub`` and ``div``, code for ``make_node`` can be
shared between these Ops. Here is revised implementation of these four
arithmetic operators:

.. code-block:: python

   from theano import gof

   class BinaryDoubleOp(gof.Op):
   
       def __init__(self, name, fn):
           self.name = name
           self.fn = fn

       def __eq__(self, other):
           return type(self) == type(other) and (self.name == other.name) and (self.fn == other.fn)

       def __hash__(self):
           return hash(type(self)) ^ hash(self.name) ^ hash(self.fn)
   
       def make_node(self, x, y):
           if isinstance(x, (int, float)):
               x = gof.Constant(double, x)
           if isinstance(y, (int, float)):
               y = gof.Constant(double, y)
           if x.type != double or y.type != double:
               raise TypeError('%s only works on doubles' % self.name)
           return gof.Apply(self, [x, y], [double()])
   
       def perform(self, node, (x, y), (z, )):
           z[0] = self.fn(x, y)

       def __str__(self):
           return self.name
   
   add = BinaryDoubleOp(name = 'add',
                        fn = lambda x, y: x + y)
   
   sub = BinaryDoubleOp(name = 'sub',
                        fn = lambda x, y: x - y)
   
   mul = BinaryDoubleOp(name = 'mul',
                        fn = lambda x, y: x * y)
   
   div = BinaryDoubleOp(name = 'div',
                        fn = lambda x, y: x / y)

Instead of working directly on an instance of Op, we create a subclass of
Op that we can parametrize. All the operations we define are binary. They
all work on two inputs with type ``double``. They all return a single
Result of type ``double``. Therefore, ``make_node`` does the same thing
for all these operations, except for the Op reference ``self`` passed
as first argument to Apply.  We define ``perform`` using the function
``fn`` passed in the constructor.

This design is a flexible way to define basic operations without
duplicating code. The same way a Type subclass represents a set of
structurally similar types (see previous section), an Op subclass
represents a set of structurally similar operations: operations that
have the same input/output types, operations that only differ in one
small detail, etc. If you see common patterns in several Ops that you
want to define, it can be a good idea to abstract out what you can.
Remember that an Op is just an object which satisfies the contract
described above on this page and that you should use all the tools at
your disposal to create these objects as efficiently as possible.

**Exercise**: Make a generic DoubleOp, where the number of
arguments can also be given as a parameter.
